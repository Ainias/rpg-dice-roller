(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Roller", [], factory);
	else if(typeof exports === 'object')
		exports["Roller"] = factory();
	else
		root["Roller"] = factory();
})((typeof self !== "undefined" ? self : this), function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/dice-roll.js":
/*!**************************!*\
  !*** ./lib/dice-roll.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./lib/utils.js\");\n\n/**\n * A DiceRoll object, which takes a notation\n * and parses it in to rolls\n *\n * @type {DiceRoll}\n */\n\nconst DiceRoll = (() => {\n  /**\n   * The dice notation\n   *\n   * @type {symbol}\n   */\n  const _notation = Symbol('notation');\n  /**\n   * The parsed notation array\n   *\n   * @type {symbol}\n   */\n\n\n  const _parsedDice = Symbol('parsedDice');\n\n  const _resetTotals = Symbol('resetTotals');\n\n  const _rolls = Symbol('rolls');\n  /**\n   * The count of success rolls\n   *\n   * @type {symbol}\n   */\n\n\n  const _successes = Symbol('successes');\n  /**\n   * The roll total\n   *\n   * @type {symbol}\n   */\n\n\n  const _total = Symbol('totals');\n  /**\n   * List of callbacks used for rolling dice types\n   *\n   * @type {{default(*=): *, fudge(number): number}}\n   */\n\n\n  const diceRollMethods = {\n    /**\n     * Rolls a standard die\n     *\n     * @param sides\n     * @returns {*}\n     */\n    default(sides) {\n      return _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"diceUtils\"].generateNumber(1, sides);\n    },\n\n    /**\n     * Rolls a fudge die\n     *\n     * @param {number} numNonBlanks\n     * @returns {number}\n     */\n    fudge(numNonBlanks) {\n      let total = 0;\n\n      if (numNonBlanks === 2) {\n        // default fudge (2 of each non-blank) = 1d3 - 2\n        total = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"diceUtils\"].generateNumber(1, 3) - 2;\n      } else if (numNonBlanks === 1) {\n        // only 1 of each non-blank\n        // on 1d6 a roll of 1 = -1, 6 = +1, others = 0\n        const num = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"diceUtils\"].generateNumber(1, 6);\n\n        if (num === 1) {\n          total = -1;\n        } else if (num === 6) {\n          total = 1;\n        }\n      }\n\n      return total;\n    }\n\n  };\n  /**\n   * Checks whether value matches the given compare point\n   *\n   * @param {object} comparePoint\n   * @param {number} value\n   * @returns {boolean}\n   */\n\n  const isComparePoint = (comparePoint, value) => {\n    return comparePoint ? _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"diceUtils\"].compareNumbers(value, comparePoint.value, comparePoint.operator) : false;\n  };\n  /**\n   * Checks whether the value matches the given compare point\n   * and returns the corresponding success / failure state value\n   * success = 1, fail = 0\n   *\n   * @param {number} value\n   * @param {object} comparePoint\n   * @returns {number}\n   */\n\n\n  const getSuccessStateValue = (value, comparePoint) => {\n    return isComparePoint(comparePoint, value) ? 1 : 0;\n  };\n  /**\n   * Rolls a single die for its quantity\n   * and returns an array of the results\n   *\n   * @param {object} die\n   * @returns {Array}\n   */\n\n\n  const rollDie = die => {\n    const dieRolls = []; // list of roll results for the die\n\n    let sides = die.sides,\n        // number of sides the die has - convert percentile to 100 sides\n    callback = diceRollMethods.default; // callback method for rolling the die\n    // ensure that the roll quantity is valid\n\n    die.qty = die.qty > 0 ? die.qty : 1; // check for non-numerical dice formats\n\n    if (die.fudge) {\n      // we have a fudge dice - define the callback to return the `fudge` roll method\n      callback = diceRollMethods.fudge; // set the `sides` to the correct value for the fudge type\n\n      sides = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"diceUtils\"].isNumeric(die.fudge[1]) ? parseInt(die.fudge[1], 10) : 2;\n    } else if (typeof die.sides === 'string') {\n      if (die.sides === '%') {\n        // convert percentile to 100 sided die\n        sides = 100;\n      }\n    } // only continue if the number of sides is valid\n\n\n    if (sides) {\n      // loop through and roll for the quantity\n      for (let i = 0; i < die.qty; i++) {\n        const reRolls = []; // the rolls for the current die (only multiple rolls if exploding)\n\n        let rollCount = 0,\n            // count of rolls for this die roll (Only > 1 if exploding)\n        roll,\n            // the total rolled\n        index; // re-roll index\n        // roll the die once, then check if it exploded and keep rolling until it stops\n\n        do {\n          // the reRolls index to use\n          index = reRolls.length; // get the total rolled on this die\n\n          roll = callback.call(undefined, sides); // add the roll to our list\n\n          reRolls[index] = (reRolls[index] || 0) + roll; // subtract 1 from penetrated rolls (only consecutive rolls, after initial roll are subtracted)\n\n          if (die.penetrate && rollCount > 0) {\n            reRolls[index]--;\n          }\n\n          rollCount++;\n        } while (die.explode && isComparePoint(die.comparePoint, roll)); // add the rolls\n\n\n        dieRolls.push(...reRolls);\n      }\n    }\n\n    return dieRolls;\n  };\n  /**\n   * A DiceRoll object, which takes a notation\n   * and parses it in to rolls\n   *\n   * @param {string|Object} notation  The dice notation or object\n   */\n\n\n  class DiceRoll {\n    /**\n     * Parses the notation and rolls the dice\n     *\n     * @param notation\n     */\n    constructor(notation) {\n      if (!notation) {\n        throw new Error('DiceRoll: No notation specified');\n      } // zero the current total\n\n\n      this[_resetTotals](); // initialise the parsed dice array\n\n\n      this[_parsedDice] = [];\n\n      if (notation instanceof Object) {\n        // validate object\n        if (!notation.notation) {\n          // object doesn't contain a notation property\n          throw new Error('DiceRoll: Object has no notation: ' + notation);\n        } else if (notation.rolls) {\n          // we have rolls - validate them\n          if (!Array.isArray(notation.rolls)) {\n            // rolls is not an array\n            throw new Error('DiceRoll: Rolls must be an Array: ' + notation.rolls);\n          } else {\n            // loop through each rolls, make sure they're valid\n            notation.rolls.forEach((roll, i) => {\n              if (!Array.isArray(roll) || roll.some(isNaN)) {\n                // not all rolls are valid\n                throw new Error('DiceRoll: Rolls are invalid at index [' + i + ']: ' + roll);\n              }\n            });\n          }\n        } // store the notation\n\n\n        this[_notation] = notation.notation; // store the rolls\n\n        this[_rolls] = notation.rolls || []; // parse the notation\n\n        this[_parsedDice] = DiceRoll.parseNotation(this.notation);\n      } else if (typeof notation === 'string') {\n        // store the notation\n        this[_notation] = notation; // empty the current rolls\n\n        this[_rolls] = []; // parse the notation\n\n        this[_parsedDice] = DiceRoll.parseNotation(this.notation); // roll the dice\n\n        this.roll();\n      } else {\n        throw new Error('DiceRoll: Notation is not valid');\n      }\n    }\n    /** Private methods **/\n\n    /**\n     * Resets the current total and success count\n     *\n     * @private\n     */\n\n\n    [_resetTotals]() {\n      this[_total] = 0;\n      this[_successes] = 0;\n    }\n    /** Public methods **/\n\n    /**\n     * Rolls the dice for the existing notation.\n     * This is useful if you want to re-roll the dice,\n     * for some reason, but it's usually better to\n     * create a new DiceRoll instance instead.\n     *\n     * @returns {Array}\n     */\n\n\n    roll() {\n      // clear the roll log\n      this[_rolls] = []; // reset the cached total\n\n      this[_resetTotals](); // loop through each die and roll it\n\n\n      this[_parsedDice].forEach(elm => {\n        // Roll the dice and add it to the log\n        this[_rolls].push(rollDie(elm));\n      }); // return the rolls;\n\n\n      return this[_rolls];\n    }\n    /**\n     * Returns the roll notation and rolls in the format of:\n     * 2d20+1d6: [20,2]+[2] = 24\n     *\n     * @returns {string}\n     */\n\n\n    get output() {\n      let output = this.notation + ': ';\n\n      if (this[_parsedDice] && Array.isArray(this.rolls) && this.rolls.length) {\n        // loop through and build the string for die rolled\n        this[_parsedDice].forEach((item, index) => {\n          const rolls = this.rolls[index] || [],\n                hasComparePoint = item.comparePoint; // current roll total - used for totalling compounding rolls\n\n          let currentRoll = 0;\n          output += (index > 0 ? item.operator : '') + '['; // output the rolls\n\n          rolls.forEach((roll, rIndex, array) => {\n            // get the roll value to compare to (If penetrating and not the first roll, add 1, to compensate for the penetration)\n            const rollVal = item.penetrate && currentRoll ? roll + 1 : roll,\n                  hasMatchedCP = hasComparePoint && isComparePoint(item.comparePoint, rollVal);\n            let delimit = rIndex !== array.length - 1;\n\n            if (item.explode && hasMatchedCP) {\n              // this die roll exploded (Either matched the explode value or is greater than the max - exploded and compounded)\n              // add the current roll to the roll total\n              currentRoll += roll;\n\n              if (item.compound) {\n                // do NOT add the delimiter after this roll as we're not outputting it\n                delimit = false;\n              } else {\n                // not compounding\n                output += roll + '!' + (item.penetrate ? 'p' : '');\n              }\n            } else if (hasMatchedCP) {\n              // not exploding but we've matched a compare point - this is a pool dice (success or failure)\n              output += roll + '*';\n            } else if (item.compound && currentRoll) {\n              // last roll in a compounding set (This one didn't compound)\n              output += roll + currentRoll + '!!' + (item.penetrate ? 'p' : ''); // reset current roll total\n\n              currentRoll = 0;\n            } else {\n              // just a normal roll\n              output += roll; // reset current roll total\n\n              currentRoll = 0;\n            }\n\n            if (delimit) {\n              output += ',';\n            }\n          });\n          output += ']'; // add any additions\n\n          if (item.additions.length) {\n            output += item.additions.reduce((prev, current) => prev + current.operator + current.value, '');\n          }\n        }); // add the total\n\n\n        output += ' = ' + this.total;\n      } else {\n        output += 'No dice rolled';\n      }\n\n      return output;\n    }\n    /**\n     * The dice notation\n     *\n     * @returns {string}\n     */\n\n\n    get notation() {\n      return this[_notation] || '';\n    }\n    /**\n     * Rolls for the notation\n     *\n     * @returns {Array}\n     */\n\n\n    get rolls() {\n      return this[_rolls] || [];\n    }\n    /**\n     * Returns the count of successes for the roll\n     *\n     * @returns {number}\n     */\n\n\n    get successes() {\n      if (!this[_successes]) {\n        // no successes found - calculate the totals, which also calculates the successes\n        // calling the `total` property calculates the total\n        let total = this.total;\n      }\n\n      return this[_successes] || 0;\n    }\n    /**\n     * Returns the roll total\n     *\n     * @returns {number}\n     */\n\n\n    get total() {\n      // only calculate the total if it has not already been done\n      if (!this[_total] && this[_parsedDice] && Array.isArray(this.rolls) && this.rolls.length) {\n        // reset the success count\n        this[_successes] = 0; // loop through each roll and calculate the totals\n\n        this[_parsedDice].forEach((item, index) => {\n          let rolls = this.rolls[index] || [],\n              dieTotal = 0; // actual values of the rolls for the purposes of L/H modifiers\n\n          const rollsValues = item.compound ? [rolls.reduce((a, b) => a + b, 0)] : rolls,\n                isPool = !item.explode && item.comparePoint;\n\n          if (isPool) {\n            // pool dice are success/failure so we don't want the actual dice roll\n            // we need to convert each roll to 1 (success) or 0 (failure)\n            rolls = rolls.map(value => getSuccessStateValue(value, item.comparePoint));\n          } // add all the rolls together to get the total\n\n\n          dieTotal = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"diceUtils\"].sumArray(rolls);\n\n          if (item.additions.length) {\n            // loop through the additions and handle them\n            item.additions.forEach(aItem => {\n              let value = aItem.value,\n                  isPoolModifier = false; // run any necessary addition value modifications\n\n              if (value === 'H') {\n                // 'H' is equivalent to the highest roll\n                value = Math.max(...rollsValues); // flag that this value needs to eb modified to a success/failure value\n\n                isPoolModifier = true;\n              } else if (value === 'L') {\n                // 'L' is equivalent to the lowest roll\n                value = Math.min(...rollsValues); // flag that this value needs to eb modified to a success/failure value\n\n                isPoolModifier = true;\n              }\n\n              if (isPool && isPoolModifier) {\n                // pool dice are either success or failure, so value is converted to 1 or 0\n                value = getSuccessStateValue(value, item.comparePoint);\n              } // run the actual mathematical equation\n\n\n              dieTotal = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"diceUtils\"].equateNumbers(dieTotal, value, aItem.operator);\n            });\n          } // total the value\n\n\n          this[_total] = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"diceUtils\"].equateNumbers(this[_total], dieTotal, item.operator); // if this is a pool dice, add it's success count to the count\n\n          if (isPool) {\n            this[_successes] = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"diceUtils\"].equateNumbers(this[_successes], dieTotal, item.operator);\n          }\n        }); // if a total has been calculated round it to 2 decimal places\n\n\n        if (this[_total]) {\n          this[_total] = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"diceUtils\"].toFixed(this[_total], 2);\n        }\n      } // return the total\n\n\n      return this[_total] || 0;\n    }\n    /**\n     * Exports the DiceRoll in the given format.\n     * If no format is specified, JSON is returned.\n     *\n     * @throws Error\n     * @param {exportFormats=} format The format to export the data as (ie. JSON, base64)\n     * @returns {string|null}\n     */\n\n\n    export(format = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"exportFormats\"].JSON) {\n      switch (format) {\n        case _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"exportFormats\"].BASE_64:\n          // JSON encode, then base64, otherwise it exports the string representation of the roll output\n          return btoa(this.export(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"exportFormats\"].JSON));\n\n        case _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"exportFormats\"].JSON:\n          return JSON.stringify(this);\n\n        case _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"exportFormats\"].OBJECT:\n          return JSON.parse(this.export(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"exportFormats\"].JSON));\n\n        default:\n          throw new Error('DiceRoll: Unrecognised export format specified: ' + format);\n      }\n    }\n    /**\n     * Returns the String representation\n     * of the object as the roll notation\n     *\n     * @returns {string}\n     */\n\n\n    toString() {\n      return this.output;\n    }\n    /**\n     * Returns an object for JSON serialising\n     *\n     * @returns {{}}\n     */\n\n\n    toJSON() {\n      const {\n        notation,\n        rolls\n      } = this;\n      return {\n        notation,\n        rolls\n      };\n    }\n    /**\n     * Imports the given dice roll data and builds a `DiceRoll` object\n     * from it.\n     *\n     * Throws Error on failure\n     *\n     * @throws Error\n     * @param {*} data The data to import\n     * @returns {DiceRoll}\n     */\n\n\n    static import(data) {\n      if (!data) {\n        throw new Error('DiceRoll: No data to import');\n      } else if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"diceUtils\"].isJson(data)) {\n        // data is JSON format - parse and import\n        return DiceRoll.import(JSON.parse(data));\n      } else if (_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"diceUtils\"].isBase64(data)) {\n        // data is base64 encoded - decode and import\n        return DiceRoll.import(atob(data));\n      } else if (typeof data === 'object') {\n        if (data.constructor.name === 'DiceRoll') {\n          // already a DiceRoll object\n          return data;\n        } else {\n          return new DiceRoll(data);\n        }\n      } else {\n        throw new Error('DiceRoll: Unrecognised import format for data: ' + data);\n      }\n    }\n    /**\n     * Parses the given dice notation\n     * and returns a list of dice found\n     *\n     * @link https://en.m.wikipedia.org/wiki/Dice_notation\n     * @param {string} notation\n     * @returns {Array}\n     */\n\n\n    static parseNotation(notation) {\n      const parsed = []; // only continue if a notation was passed\n\n      if (notation) {\n        // parse the notation and find each valid dice (and any attributes)\n        const pattern = this.notationPatterns.get('notation', 'g');\n        let match;\n\n        while ((match = pattern.exec(notation)) !== null) {\n          const die = {\n            operator: match[1] || '+',\n            // dice operator for concatenating with previous rolls (+, -, /, *)\n            qty: match[2] ? parseInt(match[2], 10) : 1,\n            // number of times to roll the die\n            sides: _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"diceUtils\"].isNumeric(match[3]) ? parseInt(match[3], 10) : match[3],\n            // how many sides the die has - only parse numerical values to Int\n            fudge: false,\n            // if fudge die this is set to the fudge notation match\n            explode: !!match[5],\n            // flag - whether to explode the dice rolls or not\n            penetrate: match[5] === '!p' || match[5] === '!!p',\n            // flag - whether to penetrate the dice rolls or not\n            compound: match[5] === '!!' || match[5] === '!!p',\n            // flag - whether to compound exploding dice or not\n            comparePoint: false,\n            // the compare point for exploding/penetrating dice\n            additions: [] // any additions (ie. +2, -L)\n\n          }; // check if it's a fudge die\n\n          if (typeof die.sides === 'string') {\n            die.fudge = die.sides.match(this.notationPatterns.get('fudge', null, true)) || false;\n          } // check if we have a compare point\n\n\n          if (match[6]) {\n            die.comparePoint = {\n              operator: match[6],\n              value: parseInt(match[7], 10)\n            };\n          } else if (die.explode) {\n            // we are exploding the dice so we need a compare point, but none has been defined\n            die.comparePoint = {\n              operator: '=',\n              value: die.fudge ? 1 : die.sides === '%' ? 100 : die.sides\n            };\n          } // check if we have additions\n\n\n          if (match[8]) {\n            // we have additions (ie. +2, -L)\n            let additionMatch;\n\n            while (!!(additionMatch = this.notationPatterns.get('addition', 'g').exec(match[8]))) {\n              // add the addition to the list\n              die.additions.push({\n                // addition operator for concatenating with the dice (+, -, /, *)\n                operator: additionMatch[1],\n                // addition value - either numerical or string 'L' or 'H'\n                value: _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"diceUtils\"].isNumeric(additionMatch[2]) ? parseFloat(additionMatch[2]) : additionMatch[2]\n              });\n            }\n          }\n\n          parsed.push(die);\n        }\n      } // return the parsed dice\n\n\n      return parsed;\n    }\n\n  }\n  /**\n   * Stores a list of regular expression\n   * patterns for dice notations.\n   * They can be retrieved, by name, using\n   * the `get(name)` method\n   *\n   * @type {{get}}\n   */\n\n\n  DiceRoll.notationPatterns = (() => {\n    const strings = {\n      /**\n       * Matches a basic arithmetic operator\n       *\n       * @type {string}\n       */\n      arithmeticOperator: '[+\\\\-*\\\\/]',\n\n      /**\n       * Matches a basic comparison operator\n       *\n       * @type {string}\n       */\n      comparisonOperators: '[<>!]?={1,3}|[<>]',\n\n      /**\n       * Matches the numbers for a 'fudge' die (ie. F, F.2)\n       *\n       * @type {string}\n       */\n      fudge: 'F(?:\\\\.([12]))?',\n\n      /**\n       * Matches a number comparison (ie. <=4, =5, >3, !=1, < 2.6)\n       *\n       * @type {string}\n       */\n      get numberComparison() {\n        return `(${this.comparisonOperators})(${this.numberDecimal})`;\n      },\n\n      /**\n       * Matches exploding/penetrating dice notation\n       *\n       * @type {string}\n       */\n      explode: '(!{1,2}p?)',\n\n      /**\n       * Matches a dice (ie. 2d6, d10, d%, dF, dF.2)\n       *\n       * @returns {string}\n       */\n      get dice() {\n        return `([1-9]\\\\d*)?d([1-9]\\\\d*|%|${this.fudge})`;\n      },\n\n      /**\n       * Matches a dice, optional exploding/penetrating notation and roll comparison\n       *\n       * @type {string}\n       */\n      get diceFull() {\n        return `${this.dice}${this.explode}?(?:${this.numberComparison})?`;\n      },\n\n      /**\n       * Matches the addition to a dice (ie. +4, -10, *2, -L)\n       *\n       * @type {string}\n       */\n      get addition() {\n        return `(${this.arithmeticOperator})(${this.numberDecimal}(?!\\\\d*d)|H|L)`;\n      },\n\n      /**\n       * Matches a standard dice notation. i.e;\n       * 3d10-2\n       * 4d20-L\n       * 2d7/4\n       * 3d8*2\n       * 2d3+4-1\n       * 2d10-H*1d6/2\n       *\n       * @type {string}\n       */\n      get notation() {\n        return `(${this.arithmeticOperator})?${this.diceFull}((?:${this.addition})*)`;\n      },\n\n      numberDecimal: '\\\\d+(?:\\\\.\\\\d+)?'\n    }; // list of cached patterns\n\n    const regExp = {};\n    return {\n      /**\n       * @param {string} name\n       * @param {string=} flags\n       * @param {boolean=} matchWhole\n       * @returns {RegExp}\n       */\n      get(name, flags, matchWhole = false) {\n        const cacheName = name + '_' + flags + '_' + (matchWhole ? 't' : 'f');\n\n        if (!name) {\n          throw new Error('DiceRoller: Notation pattern name not defined');\n        } else if (typeof name !== 'string' || !strings[name]) {\n          throw new Error(`DiceRoller: Notation pattern name not found: ${name}`);\n        } else if (!regExp[cacheName]) {\n          // no cached version - create it\n          regExp[cacheName] = new RegExp((matchWhole ? '^' : '') + strings[name] + (matchWhole ? '$' : ''), flags || undefined);\n        }\n\n        return regExp[cacheName];\n      }\n\n    };\n  })();\n\n  return DiceRoll;\n})();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (DiceRoll);\n\n//# sourceURL=webpack://Roller/./lib/dice-roll.js?");

/***/ }),

/***/ "./lib/dice-roller.js":
/*!****************************!*\
  !*** ./lib/dice-roller.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dice_roll_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dice-roll.js */ \"./lib/dice-roll.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./lib/utils.js\");\n\n\n/**\n * A DiceRoller handles dice rolling functionality,\n * keeps track of rolls and can output logs etc.\n *\n * @type {DiceRoller}\n */\n\nconst DiceRoller = (() => {\n  /**\n   * history of log rolls\n   *\n   * @type {symbol}\n   */\n  const _log = Symbol('log');\n  /**\n   * A DiceRoller handles dice rolling functionality,\n   * keeps track of rolls and can output logs etc.\n   *\n   * @param {{}=} data\n   */\n\n\n  class DiceRoller {\n    /**\n     * Initialises the object\n     *\n     * @constructor\n     * @param data\n     */\n    constructor(data) {\n      this[_log] = [];\n\n      if (data) {\n        if (Array.isArray(data.log)) {\n          // loop through each log entry and import it\n          data.log.forEach(roll => {\n            this[_log].push(_dice_roll_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].import(roll));\n          });\n        } else if (data.log) {\n          throw new Error('DiceRoller: Roll log must be an Array');\n        }\n      }\n    }\n    /**\n     * Returns the roll notation and rolls in the format of:\n     * 2d20+1d6: [20,2]+[2] = 24; 1d8: [6] = 6\n     *\n     * @returns {string}\n     */\n\n\n    get output() {\n      // return the log as a joined string\n      return this.log.join('; ');\n    }\n    /**\n     * Rolls the given dice notation.\n     * Returns a list of results\n     *\n     * @param {string} notation\n     * @returns {DiceRoll}\n     */\n\n\n    roll(notation) {\n      let diceRoll = new _dice_roll_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](notation); // add the roll log to our global log\n\n      this[_log].push(diceRoll); // return the current DiceRoll\n\n\n      return diceRoll;\n    }\n    /**\n     * Rolls the given list of dice notations\n     * and returns a list of the DiceRolls\n     *\n     * @param {Array} notations\n     * @returns {Array}\n     */\n\n\n    rollMany(notations) {\n      if (!notations) {\n        throw new Error('DiceRoller: No notations specified');\n      } else if (!Array.isArray(notations)) {\n        throw new Error('DiceRoller: Notations are not valid');\n      } else {\n        // loop through and roll each notation, add it to the log and return it\n        return notations.map(notation => this.roll(notation));\n      }\n    }\n    /**\n     * Clears the roll history log\n     */\n\n\n    clearLog() {\n      this[_log].length = 0;\n    }\n    /**\n     * Returns the current roll log\n     *\n     * @returns {Array}\n     */\n\n\n    get log() {\n      return this[_log] || [];\n    }\n    /**\n     * Exports the roll log in the given format.\n     * If no format is specified, JSON is returned.\n     *\n     * @throws Error\n     * @param {exportFormats=} format The format to export the data as (ie. JSON, base64)\n     * @returns {string|null}\n     */\n\n\n    export(format) {\n      switch (format || _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"exportFormats\"].JSON) {\n        case _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"exportFormats\"].BASE_64:\n          // JSON encode, then base64\n          return btoa(this.export(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"exportFormats\"].JSON));\n\n        case _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"exportFormats\"].JSON:\n          return JSON.stringify(this);\n\n        default:\n          throw new Error('DiceRoller: Unrecognised export format specified: ' + format);\n      }\n    }\n    /**\n     * Takes the given roll data and imports it into\n     * the existing DiceRoller, appending the rolls\n     * to the current roll log.\n     * Returns the roll log.\n     *\n     * @throws Error\n     * @param data\n     * @returns {array}\n     */\n\n\n    import(data) {\n      if (!data) {\n        throw new Error('DiceRoller: No data to import');\n      } else if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"diceUtils\"].isJson(data)) {\n        // data is JSON - parse and import\n        return this.import(JSON.parse(data));\n      } else if (_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"diceUtils\"].isBase64(data)) {\n        // data is base64 encoded - decode an import\n        return this.import(atob(data));\n      } else if (typeof data === 'object') {\n        // if `log` is not defined, but data is an array, use it as the list of logs\n        if (!data.log && Array.isArray(data) && data.length) {\n          data = {\n            log: data\n          };\n        }\n\n        if (data.log && Array.isArray(data.log)) {\n          // loop through each log entry and import it\n          data.log.forEach(roll => {\n            this[_log].push(_dice_roll_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].import(roll));\n          });\n        } else if (data.log) {\n          throw new Error('DiceRoller: Roll log must be an Array');\n        }\n\n        return this.log;\n      } else {\n        throw new Error('DiceRoller: Unrecognised import format for data: ' + data);\n      }\n    }\n    /**\n     * Returns the String representation\n     * of the object as the roll notations\n     *\n     * @returns {string}\n     */\n\n\n    toString() {\n      return this.output;\n    }\n    /**\n     * Returns an object for JSON serialising\n     *\n     * @returns {{}}\n     */\n\n\n    toJSON() {\n      const {\n        log\n      } = this;\n      return {\n        log\n      };\n    }\n    /**\n     * Takes the given data, imports it into a new DiceRoller instance\n     * and returns the DiceRoller\n     *\n     * @throws Error\n     * @param data\n     * @returns {DiceRoller}\n     */\n\n\n    static import(data) {\n      // create a new DiceRoller object\n      const diceRoller = new DiceRoller(); // import the data\n\n      diceRoller.import(data); // return the DiceRoller\n\n      return diceRoller;\n    }\n\n  }\n\n  return DiceRoller;\n})();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (DiceRoller);\n\n//# sourceURL=webpack://Roller/./lib/dice-roller.js?");

/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/*! exports provided: DiceRoller, DiceRoll, diceUtils, exportFormats */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dice_roller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dice-roller.js */ \"./lib/dice-roller.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DiceRoller\", function() { return _dice_roller_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _dice_roll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dice-roll.js */ \"./lib/dice-roll.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DiceRoll\", function() { return _dice_roll_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./lib/utils.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"diceUtils\", function() { return _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"diceUtils\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"exportFormats\", function() { return _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"exportFormats\"]; });\n\n/**\n * A JS based dice roller that uses dice notation, as described here:\n * https://en.m.wikipedia.org/wiki/Dice_notation\n *\n * @version v2.0.1\n * @author GreenImp - greenimp.co.uk\n * @link https://github.com/GreenImp/rpg-dice-roller\n */\n\n\n\n\n\n//# sourceURL=webpack://Roller/./lib/index.js?");

/***/ }),

/***/ "./lib/utils.js":
/*!**********************!*\
  !*** ./lib/utils.js ***!
  \**********************/
/*! exports provided: diceUtils, exportFormats */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"diceUtils\", function() { return diceUtils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exportFormats\", function() { return exportFormats; });\n/**\n * Utility helper functions\n *\n * @type {Readonly<{compareNumbers(number, number, string): boolean, toFixed(number, number=): number, generateNumber((number|string), (number|string)): *, isNumeric(*=): boolean, isJson(*=): (*|boolean|undefined), sumArray(Array): number, equateNumbers(number, number, string=): number, isBase64(*=): (*|boolean|undefined)}>}\n */\nconst diceUtils = Object.freeze({\n  /**\n   * Checks if the given val is a valid number\n   *\n   * @param val\n   * @returns {boolean}\n   */\n  isNumeric(val) {\n    return !Array.isArray(val) && !Number.isNaN(val) && Number.isFinite(parseInt(val, 10));\n  },\n\n  isBase64(val) {\n    try {\n      return !!(val && btoa(atob(val)) === val);\n    } catch (e) {\n      return false;\n    }\n  },\n\n  isJson(val) {\n    try {\n      let parsed = val ? JSON.parse(val) : false;\n      return !!(parsed && typeof parsed === 'object');\n    } catch (e) {\n      return false;\n    }\n  },\n\n  /**\n   * Generates a random number between the\n   * min and max, inclusive\n   *\n   * @param {number|string} min\n   * @param {number|string} max\n   * @returns {*}\n   */\n  generateNumber(min, max) {\n    min = min ? parseInt(min, 10) : 1;\n    max = max ? parseInt(max, 10) : min;\n\n    if (max <= min) {\n      return min;\n    }\n\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  },\n\n  /**\n   * @returns {function(Array): number}\n   */\n  get sumArray() {\n    /**\n     * Takes an array of numbers and adds them together,\n     * returning the result\n     *\n     * @param {Array} numbers\n     * @returns {number}\n     */\n    return numbers => !Array.isArray(numbers) ? 0 : numbers.reduce((prev, current) => prev + (this.isNumeric(current) ? parseFloat(current) : 0), 0);\n  },\n\n  /**\n   * @returns {function(number, number, string=): number}\n   */\n  get equateNumbers() {\n    /**\n     * Takes two numbers and runs a\n     * mathematical equation on them,\n     * using the given operator\n     *\n     * @param {number} a\n     * @param {number} b\n     * @param {string=} operator A valid arithmetic operator (+, -, /, *)\n     * @returns {number}\n     */\n    return (a, b, operator = '+') => {\n      // ensure values are numeric\n      a = this.isNumeric(a) ? parseFloat(a) : 0;\n      b = this.isNumeric(b) ? parseFloat(b) : 0; // only carry out operation if we have both values\n\n      switch (operator) {\n        case '*':\n          // multiply the value\n          a *= b;\n          break;\n\n        case '/':\n          // divide the value (Handle division by zero)\n          a = b ? a / b : 0;\n          break;\n\n        case '-':\n          // subtract from the value\n          a -= b;\n          break;\n\n        default:\n          // add to the value\n          a += b;\n          break;\n      }\n\n      return a;\n    };\n  },\n\n  /**\n   * Checks if `a` is comparative to `b` with the given operator.\n   * Returns true or false.\n   *\n   * @param {number} a\n   * @param {number} b\n   * @param {string} operator A valid comparative operator (=, <, >, <=, >=, !=)\n   * @returns {boolean}\n   */\n  compareNumbers(a, b, operator) {\n    let result;\n    a = parseFloat(a);\n    b = parseFloat(b);\n\n    switch (operator) {\n      case '=':\n      case '==':\n        result = a === b;\n        break;\n\n      case '<':\n        result = a < b;\n        break;\n\n      case '>':\n        result = a > b;\n        break;\n\n      case '<=':\n        result = a <= b;\n        break;\n\n      case '>=':\n        result = a >= b;\n        break;\n\n      case '!':\n      case '!=':\n        result = a !== b;\n        break;\n\n      default:\n        result = false;\n        break;\n    }\n\n    return result;\n  },\n\n  /**\n   * Rounds a number to the given number of decimal places,\n   * removing any trailing zeros after the decimal point.\n   *\n   * `toFixed(1.236, 2) == 1.24`\n   * `toFixed(30.1, 2) == 30.1`\n   * `toFixed(4.0000000004, 3) == 4`\n   *\n   * @param {number} num\n   * @param {number=} decPlaces\n   * @returns {number}\n   */\n  toFixed(num, decPlaces) {\n    // round to the specified decimal places, then convert back to\n    // a number to remove trailing zeroes after the decimal point\n    return parseFloat(num.toFixed(decPlaces || 0));\n  }\n\n});\n/**\n * Allowed formats for exporting dice data\n *\n * @type {Readonly<{BASE_64: number, JSON: number, OBJECT: number}>}\n */\n\nconst exportFormats = Object.freeze({\n  JSON: 0,\n  BASE_64: 1,\n  OBJECT: 2\n});\n\n\n//# sourceURL=webpack://Roller/./lib/utils.js?");

/***/ })

/******/ });
});