!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("Roller",[],e):"object"==typeof exports?exports.Roller=e():t.Roller=e()}("undefined"!=typeof self?self:this,function(){return function(t){var e={};function r(o){if(e[o])return e[o].exports;var i=e[o]={i:o,l:!1,exports:{}};return t[o].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=t,r.c=e,r.d=function(t,e,o){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)r.d(o,i,function(e){return t[e]}.bind(null,i));return o},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=0)}([function(t,e,r){"use strict";r.r(e);const o=Object.freeze({isNumeric:t=>!Array.isArray(t)&&!Number.isNaN(t)&&Number.isFinite(parseInt(t,10)),isBase64(t){try{return!(!t||btoa(atob(t))!==t)}catch(t){return!1}},isJson(t){try{let e=!!t&&JSON.parse(t);return!(!e||"object"!=typeof e)}catch(t){return!1}},generateNumber:(t,e)=>(t=t?parseInt(t,10):1,(e=e?parseInt(e,10):t)<=t?t:Math.floor(Math.random()*(e-t+1)+t)),get sumArray(){return t=>Array.isArray(t)?t.reduce((t,e)=>t+(this.isNumeric(e)?parseFloat(e):0),0):0},get equateNumbers(){return(t,e,r="+")=>{switch(t=this.isNumeric(t)?parseFloat(t):0,e=this.isNumeric(e)?parseFloat(e):0,r){case"*":t*=e;break;case"/":t=e?t/e:0;break;case"-":t-=e;break;default:t+=e}return t}},compareNumbers(t,e,r){let o;switch(t=parseFloat(t),e=parseFloat(e),r){case"=":case"==":o=t===e;break;case"<":o=t<e;break;case">":o=t>e;break;case"<=":o=t<=e;break;case">=":o=t>=e;break;case"!":case"!=":o=t!==e;break;default:o=!1}return o},toFixed:(t,e)=>parseFloat(t.toFixed(e||0))}),i=Object.freeze({JSON:0,BASE_64:1,OBJECT:2});var n=(()=>{const t=Symbol("notation"),e=Symbol("parsedDice"),r=Symbol("resetTotals"),n=Symbol("rolls"),s=Symbol("successes"),a=Symbol("totals"),l={default:t=>o.generateNumber(1,t),fudge(t){let e=0;if(2===t)e=o.generateNumber(1,3)-2;else if(1===t){const t=o.generateNumber(1,6);1===t?e=-1:6===t&&(e=1)}return e}},u=(t,e)=>!!t&&o.compareNumbers(e,t.value,t.operator),c=(t,e)=>u(e,t)?1:0,p=t=>{const e=[];let r=t.sides,i=l.default;if(t.qty=t.qty>0?t.qty:1,t.fudge?(i=l.fudge,r=o.isNumeric(t.fudge[1])?parseInt(t.fudge[1],10):2):"string"==typeof t.sides&&"%"===t.sides&&(r=100),r)for(let o=0;o<t.qty;o++){const o=[];let n,s,a=0;do{s=o.length,n=i.call(void 0,r),o[s]=(o[s]||0)+n,t.penetrate&&a>0&&o[s]--,a++}while(t.explode&&u(t.comparePoint,n));e.push(...o)}return e};class h{constructor(o){if(!o)throw new Error("DiceRoll: No notation specified");if(this[r](),this[e]=[],o instanceof Object){if(!o.notation)throw new Error("DiceRoll: Object has no notation: "+o);if(o.rolls){if(!Array.isArray(o.rolls))throw new Error("DiceRoll: Rolls must be an Array: "+o.rolls);o.rolls.forEach((t,e)=>{if(!Array.isArray(t)||t.some(isNaN))throw new Error("DiceRoll: Rolls are invalid at index ["+e+"]: "+t)})}this[t]=o.notation,this[n]=o.rolls||[],this[e]=h.parseNotation(this.notation)}else{if("string"!=typeof o)throw new Error("DiceRoll: Notation is not valid");this[t]=o,this[n]=[],this[e]=h.parseNotation(this.notation),this.roll()}}[r](){this[a]=0,this[s]=0}roll(){return this[n]=[],this[r](),this[e].forEach(t=>{this[n].push(p(t))}),this[n]}get output(){let t=this.notation+": ";return this[e]&&Array.isArray(this.rolls)&&this.rolls.length?(this[e].forEach((e,r)=>{const o=this.rolls[r]||[],i=e.comparePoint;let n=0;t+=(r>0?e.operator:"")+"[",o.forEach((r,o,s)=>{const a=e.penetrate&&n?r+1:r,l=i&&u(e.comparePoint,a);let c=o!==s.length-1;e.explode&&l?(n+=r,e.compound?c=!1:t+=r+"!"+(e.penetrate?"p":"")):l?t+=r+"*":e.compound&&n?(t+=r+n+"!!"+(e.penetrate?"p":""),n=0):(t+=r,n=0),c&&(t+=",")}),t+="]",e.additions.length&&(t+=e.additions.reduce((t,e)=>t+e.operator+e.value,""))}),t+=" = "+this.total):t+="No dice rolled",t}get notation(){return this[t]||""}get rolls(){return this[n]||[]}get successes(){if(!this[s]){this.total}return this[s]||0}get total(){return!this[a]&&this[e]&&Array.isArray(this.rolls)&&this.rolls.length&&(this[s]=0,this[e].forEach((t,e)=>{let r=this.rolls[e]||[],i=0;const n=t.compound?[r.reduce((t,e)=>t+e,0)]:r,l=!t.explode&&t.comparePoint;l&&(r=r.map(e=>c(e,t.comparePoint))),i=o.sumArray(r),t.additions.length&&t.additions.forEach(e=>{let r=e.value,s=!1;"H"===r?(r=Math.max(...n),s=!0):"L"===r&&(r=Math.min(...n),s=!0),l&&s&&(r=c(r,t.comparePoint)),i=o.equateNumbers(i,r,e.operator)}),this[a]=o.equateNumbers(this[a],i,t.operator),l&&(this[s]=o.equateNumbers(this[s],i,t.operator))}),this[a]&&(this[a]=o.toFixed(this[a],2))),this[a]||0}export(t=i.JSON){switch(t){case i.BASE_64:return btoa(this.export(i.JSON));case i.JSON:return JSON.stringify(this);case i.OBJECT:return JSON.parse(this.export(i.JSON));default:throw new Error("DiceRoll: Unrecognised export format specified: "+t)}}toString(){return this.output}toJSON(){const{notation:t,rolls:e}=this;return{notation:t,rolls:e}}static import(t){if(t){if(o.isJson(t))return h.import(JSON.parse(t));if(o.isBase64(t))return h.import(atob(t));if("object"==typeof t)return"DiceRoll"===t.constructor.name?t:new h(t);throw new Error("DiceRoll: Unrecognised import format for data: "+t)}throw new Error("DiceRoll: No data to import")}static parseNotation(t){const e=[];if(t){const r=this.notationPatterns.get("notation","g");let i;for(;null!==(i=r.exec(t));){const t={operator:i[1]||"+",qty:i[2]?parseInt(i[2],10):1,sides:o.isNumeric(i[3])?parseInt(i[3],10):i[3],fudge:!1,explode:!!i[5],penetrate:"!p"===i[5]||"!!p"===i[5],compound:"!!"===i[5]||"!!p"===i[5],comparePoint:!1,additions:[]};if("string"==typeof t.sides&&(t.fudge=t.sides.match(this.notationPatterns.get("fudge",null,!0))||!1),i[6]?t.comparePoint={operator:i[6],value:parseInt(i[7],10)}:t.explode&&(t.comparePoint={operator:"=",value:t.fudge?1:"%"===t.sides?100:t.sides}),i[8]){let e;for(;e=this.notationPatterns.get("addition","g").exec(i[8]);)t.additions.push({operator:e[1],value:o.isNumeric(e[2])?parseFloat(e[2]):e[2]})}e.push(t)}}return e}}return h.notationPatterns=(()=>{const t={arithmeticOperator:"[+\\-*\\/]",comparisonOperators:"[<>!]?={1,3}|[<>]",fudge:"F(?:\\.([12]))?",get numberComparison(){return`(${this.comparisonOperators})(${this.numberDecimal})`},explode:"(!{1,2}p?)",get dice(){return`([1-9]\\d*)?d([1-9]\\d*|%|${this.fudge})`},get diceFull(){return`${this.dice}${this.explode}?(?:${this.numberComparison})?`},get addition(){return`(${this.arithmeticOperator})(${this.numberDecimal}(?!\\d*d)|H|L)`},get notation(){return`(${this.arithmeticOperator})?${this.diceFull}((?:${this.addition})*)`},numberDecimal:"\\d+(?:\\.\\d+)?"},e={};return{get(r,o,i=!1){const n=r+"_"+o+"_"+(i?"t":"f");if(!r)throw new Error("DiceRoller: Notation pattern name not defined");if("string"!=typeof r||!t[r])throw new Error(`DiceRoller: Notation pattern name not found: ${r}`);return e[n]||(e[n]=new RegExp((i?"^":"")+t[r]+(i?"$":""),o||void 0)),e[n]}}})(),h})();var s=(()=>{const t=Symbol("log");class e{constructor(e){if(this[t]=[],e)if(Array.isArray(e.log))e.log.forEach(e=>{this[t].push(n.import(e))});else if(e.log)throw new Error("DiceRoller: Roll log must be an Array")}get output(){return this.log.join("; ")}roll(e){let r=new n(e);return this[t].push(r),r}rollMany(t){if(t){if(Array.isArray(t))return t.map(t=>this.roll(t));throw new Error("DiceRoller: Notations are not valid")}throw new Error("DiceRoller: No notations specified")}clearLog(){this[t].length=0}get log(){return this[t]||[]}export(t){switch(t||i.JSON){case i.BASE_64:return btoa(this.export(i.JSON));case i.JSON:return JSON.stringify(this);default:throw new Error("DiceRoller: Unrecognised export format specified: "+t)}}import(e){if(e){if(o.isJson(e))return this.import(JSON.parse(e));if(o.isBase64(e))return this.import(atob(e));if("object"==typeof e){if(!e.log&&Array.isArray(e)&&e.length&&(e={log:e}),e.log&&Array.isArray(e.log))e.log.forEach(e=>{this[t].push(n.import(e))});else if(e.log)throw new Error("DiceRoller: Roll log must be an Array");return this.log}throw new Error("DiceRoller: Unrecognised import format for data: "+e)}throw new Error("DiceRoller: No data to import")}toString(){return this.output}toJSON(){const{log:t}=this;return{log:t}}static import(t){const r=new e;return r.import(t),r}}return e})();r.d(e,"DiceRoller",function(){return s}),r.d(e,"DiceRoll",function(){return n}),r.d(e,"diceUtils",function(){return o}),r.d(e,"exportFormats",function(){return i})}])});